/***********************************************************//**                                                       **//**              6   5   0   2   P   P   C                **//**                                                       **//***********************************************************/// Download M6502.h from http://fms.komkon.org/EMUL8/#CPUs (6502 Portable Emulation Package)#include "M6502.h"#include "6502PPC.h"#include "6502PPCMacros.h"#if PPC6502static void* jumpList[256] = {  Op00, Op01, OpXX, OpXX, OpXX, Op05, Op06, OpXX, Op08, Op09, Op0A, OpXX, OpXX, Op0D, Op0E, OpXX,  Op10, Op11, OpXX, OpXX, OpXX, Op15, Op16, OpXX, Op18, Op19, OpXX, OpXX, OpXX, Op1D, Op1E, OpXX,  Op20, Op21, OpXX, OpXX, Op24, Op25, Op26, OpXX, Op28, Op29, Op2A, OpXX, Op2C, Op2D, Op2E, OpXX,  Op30, Op31, OpXX, OpXX, OpXX, Op35, Op36, OpXX, Op38, Op39, OpXX, OpXX, OpXX, Op3D, Op3E, OpXX,  Op40, Op41, OpXX, OpXX, OpXX, Op45, Op46, OpXX, Op48, Op49, Op4A, OpXX, Op4C, Op4D, Op4E, OpXX,  Op50, Op51, OpXX, OpXX, OpXX, Op55, Op56, OpXX, Op58, Op59, OpXX, OpXX, OpXX, Op5D, Op5E, OpXX,  Op60, Op61, OpXX, OpXX, OpXX, Op65, Op66, OpXX, Op68, Op69, Op6A, OpXX, Op6C, Op6D, Op6E, OpXX,  Op70, Op71, OpXX, OpXX, OpXX, Op75, Op76, OpXX, Op78, Op79, OpXX, OpXX, OpXX, Op7D, Op7E, OpXX,  OpXX, Op81, OpXX, OpXX, Op84, Op85, Op86, OpXX, Op88, OpXX, Op8A, OpXX, Op8C, Op8D, Op8E, OpXX,  Op90, Op91, OpXX, OpXX, Op94, Op95, Op96, OpXX, Op98, Op99, Op9A, OpXX, OpXX, Op9D, OpXX, OpXX,  OpA0, OpA1, OpA2, OpXX, OpA4, OpA5, OpA6, OpXX, OpA8, OpA9, OpAA, OpXX, OpAC, OpAD, OpAE, OpXX,  OpB0, OpB1, OpXX, OpXX, OpB4, OpB5, OpB6, OpXX, OpB8, OpB9, OpBA, OpXX, OpBC, OpBD, OpBE, OpXX,  OpC0, OpC1, OpXX, OpXX, OpC4, OpC5, OpC6, OpXX, OpC8, OpC9, OpCA, OpXX, OpCC, OpCD, OpCE, OpXX,  OpD0, OpD1, OpXX, OpXX, OpXX, OpD5, OpD6, OpXX, OpD8, OpD9, OpXX, OpXX, OpXX, OpDD, OpDE, OpXX,  OpE0, OpE1, OpXX, OpXX, OpE4, OpE5, OpE6, OpXX, OpE8, OpE9, OpEA, OpXX, OpEC, OpED, OpEE, OpXX,  OpF0, OpF1, OpXX, OpXX, OpXX, OpF5, OpF6, OpXX, OpF8, OpF9, OpXX, OpXX, OpXX, OpFD, OpFE, OpXX};extern byte *Page[8];void InitProcessorPPC( void ){	static int done=0;	int x;		if( done ) return;	done = 1;		for( x=0; x<0x100; x++ )	{		jumpList[x] = *(void**)jumpList[x];	}}void SuperDAsm(word A, byte rA, byte rX, byte rY, byte rS, byte rP, int cyc );asm word Run6502( register M6502 *R ){mflr		r0stmw		r13,-76(sp)stw		    r0,8(sp)stwu		sp,-128(sp)mr     M6502R, r3lwz    jumpTable, jumpList(RTOC)lwz    pageTable, Page(RTOC)lwz    zeroPage, 0(pageTable)addi   stackPage, zeroPage, 0x100addi   zeroPage800, zeroPage, 0x800addi   zeroPage1000, zeroPage, 0x1000addi   zeroPage1800, zeroPage, 0x1800bl     InitProcessorPPClbz    rA, M6502.A(M6502R)lbz    rP, M6502.P(M6502R)lbz    rX, M6502.X(M6502R)lbz    rY, M6502.Y(M6502R)lbz    rS, M6502.S(M6502R)lhz    rPC, M6502.PC(M6502R)lwz    cycles, M6502.IPeriod(M6502R)lbz    afterCLI, M6502.AfterCLI(M6502R)cmpwi  cycles, 0UnpackZnextOpcode:ble-   cyclesOutparseOpcode:Op6502( rPC, r5 )rlwinm r6, r5, 2, 0, 29lwzx   r7, jumpTable, r6addi   rPC, rPC, 1mtctr  r7bctrcyclesOut:PackZcmpwi  afterCLI, 0stb    rP, M6502.P(M6502R)stb    rS, M6502.S(M6502R)sth    rPC, M6502.PC(M6502R)beq+   notAfterCLIisAfterCLI:lbz    r4, M6502.IRequest(M6502R)add    cycles, cycles, cyclesBacksubi   cycles, cycles, 1li     afterCLI, 0b      handleIntsnotAfterCLI:stb    rA, M6502.A(M6502R)stb    rX, M6502.X(M6502R)mr     r3, M6502Rstb    rY, M6502.Y(M6502R)stw    cycles, M6502.ICount(M6502R)bl     Loop6502cmpwi  r3, 0mr     r4, r3lbz    rA, M6502.A(M6502R)lwz    r5, M6502.IPeriod(M6502R)lbz    rX, M6502.X(M6502R)lbz    rY, M6502.Y(M6502R)add    cycles, cycles, r5bne    handleIntslbz    r4, M6502.IRequest(M6502R)handleInts:cmpwi  r4, 0stw    cycles, M6502.ICount(M6502R)beq    skipIntcmpwi  r4, 3beq-   finishedmr     r3, M6502Rbl     Int6502skipInt:lbz    rP, M6502.P(M6502R)lbz    rS, M6502.S(M6502R)lhz    rPC, M6502.PC(M6502R)lwz    cycles, M6502.ICount(M6502R)UnpackZb      parseOpcode// CLI and PLP are "special" opcodes because they affect cycles register directly;// therefore they don't use EndOpcode like most other opcodes do.// They are also special because they alone use cyclesBack, afterCLI and IRequest./* CLI *///case 0x58://  if((R->IRequest!=INT_NONE)&&(P&I_FLAG))//  {//    R->AfterCLI=1;//    R->IBackup=ICount;//    ICount=1;//  }//  P&=~I_FLAG;//  break;entry static Op58rlwinm. r9, rP, 0, 29, 29 /* I_FLAG */addi   cycles, cycles, -2beq    Op58noInterruptlbz    r9, M6502.IRequest(M6502R)cmpwi  r9, 0beq    Op58noInterruptmr     cyclesBack, cyclesli     afterCLI, 1li     cycles, 1Op58noInterrupt:rlwinm rP, rP, 0, 30, 28 /* clear I_FLAG */cmpwi  cycles, 0b      nextOpcode/* PLP *///case 0x28://  M_POP(I);//  if((R->IRequest!=INT_NONE)&&((I^P)&~I&I_FLAG))//  {//    R->AfterCLI=1;//    R->IBackup=ICount;//    ICount=1;//  }//  P=I|R_FLAG;//  break;entry static Op28rlwinm. r9, rP, 0, 29, 29addi   cycles, cycles, -4Pop( r10 )beq    Op28noInterruptrlwinm. r9, r10, 0, 29, 29bne    Op28noInterruptlbz    r11, M6502.IRequest(M6502R)cmpwi  r11, 0beq    Op28noInterruptmr     cyclesBack, cyclesli     afterCLI, 1li     cycles, 1Op28noInterrupt:ori    rP, r10, R_FLAGUnpackZcmpwi  cycles, 0b      nextOpcode//case 0x10: if(P&N_FLAG) PC.W++; else { M_JR; } break; /* BPL * REL */// branch if N_FLAG is downentry static Op10BranchIfAllOff( rP, 0x80, Op10 )EndOpcode( 2 )//case 0x30: if(P&N_FLAG) { M_JR; } else PC.W++; break; /* BMI * REL */// branch if N_FLAG is upentry static Op30BranchIfAnyOn( rP, 0x80, Op30 )EndOpcode( 2 )//case 0xD0: if(P&Z_FLAG) PC.W++; else { M_JR; } break; /* BNE * REL */// branch if the Z flag is downentry static OpD0BranchIfAllOff( rZ, 0x20, OpD0 )EndOpcode( 2 )//case 0xF0: if(P&Z_FLAG) { M_JR; } else PC.W++; break; /* BEQ * REL */// branch if the Z flag is upentry static OpF0BranchIfAnyOn( rZ, 0x20, OpF0 )EndOpcode( 2 )//case 0x90: if(P&C_FLAG) PC.W++; else { M_JR; } break; /* BCC * REL */// branch if C_FLAG is downentry static Op90BranchIfAllOff( rP, C_FLAG, Op90 )EndOpcode( 2 )//case 0xB0: if(P&C_FLAG) { M_JR; } else PC.W++; break; /* BCS * REL */// branch if C_FLAG is upentry static OpB0BranchIfAnyOn( rP, C_FLAG, OpB0 )EndOpcode( 2 )//case 0x50: if(P&V_FLAG) PC.W++; else { M_JR; } break; /* BVC * REL */// branch if V_FLAG is downentry static Op50BranchIfAllOff( rP, V_FLAG, Op50 )EndOpcode( 2 )//case 0x70: if(P&V_FLAG) { M_JR; } else PC.W++; break; /* BVS * REL */// branch if V_FLAG is upentry static Op70BranchIfAnyOn( rP, V_FLAG, Op70 )EndOpcode( 2 )///* RTI *///case 0x40://  M_POP(P);P|=R_FLAG;M_POP(PC.B.l);M_POP(PC.B.h);//  break;entry static Op40Pop( rP )ori    rP, rP, R_FLAGPopPCUnpackZEndOpcode( 6 ) ///* RTS *///case 0x60://  M_POP(PC.B.l);M_POP(PC.B.h);PC.W++;break;entry static Op60PopPCaddi   rPC, rPC, 1EndOpcode( 6 )///* JSR $ssss ABS *///case 0x20://  K.B.l=Op6502(PC.W++);//  K.B.h=Op6502(PC.W);//  M_PUSH(PC.B.h);//  M_PUSH(PC.B.l);//  PC=K;break;entry static Op20PushPC( 1 )Load16FromPC( rPC, Op20 )EndOpcode( 6 )///* JMP $ssss ABS *///case 0x4C: M_LDWORD(K);PC=K;break;entry static Op4CLoad16FromPC( rPC, Op4C )EndOpcode( 3 )///* JMP ($ssss) ABDINDIR *///case 0x6C://  M_LDWORD(K);//  PC.B.l=Rd6502(K.W++);//  PC.B.h=Rd6502(K.W);//  break;entry static Op6CLoad16FromPC( workAddr, Op6C )addi   r3, workAddr, 1rlwimi r3, workAddr, 0, 16, 23 /* support 6502 bug; high byte for JMP indir does not do carry */bl     Rd6502rlwinm rPC, r3, 8, 16, 23mr     r3, workAddrbl     Rd6502rlwimi rPC, r3, 0, 24, 31EndOpcode( 5 )///* BRK *///case 0x00://  PC.W++;//  M_PUSH(PC.B.h);M_PUSH(PC.B.l);//  M_PUSH(P|B_FLAG);//  P=(P|I_FLAG)&~D_FLAG;//  PC.B.l=Rd6502(0xFFFE);//  PC.B.h=Rd6502(0xFFFF);//  break;entry static Op00ori    r9, rP, B_FLAGPushPC( 1 )Push( r9 )ori    rP, rP, I_FLAGrlwinm rP, rP, 0, 29, 27 /* clear D_FLAG */li     r3, 0xFFFEbl     Rd6502mr     rPC, r3li     r3, 0xFFFFbl     Rd6502rlwimi rPC, r3, 8, 16, 23EndOpcode( 7 )//case 0x08: M_PUSH(P);break;               /* PHP */entry static Op08PackZPush( rP )EndOpcode( 3 )//case 0x18: P&=~C_FLAG;break;              /* CLC */entry static Op18rlwinm rP, rP, 0, 0, 30 // clear C_FLAG bit 31EndOpcode( 2 )//case 0xB8: P&=~V_FLAG;break;              /* CLV */entry static OpB8rlwinm rP, rP, 0, 26, 24 // clear V_FLAG bit 25EndOpcode( 2 )//case 0xD8: P&=~D_FLAG;break;              /* CLD */entry static OpD8rlwinm rP, rP, 0, 29, 27 // clear D_FLAG bit 28EndOpcode( 2 )//case 0x38: P|=C_FLAG;break;               /* SEC */entry static Op38ori    rP, rP, 0x01      // set C_FLAG bit 31EndOpcode( 2 )//case 0xF8: P|=D_FLAG;break;               /* SED */entry static OpF8ori    rP, rP, 0x08      // set D_FLAG bit 28EndOpcode( 2 )//case 0x78: P|=I_FLAG;break;               /* SEI */entry static Op78ori    rP, rP, 0x04      // set I_FLAG bit 29EndOpcode( 2 )//case 0x48: M_PUSH(A);break;               /* PHA */entry static Op48Push( rA )EndOpcode( 3 )//case 0x68: M_POP(A);M_FL(A);break;     /* PLA */entry static Op68Pop( rA )SetZN( rA )EndOpcode( 4 )//case 0x98: A=Y;M_FL(A);break;       /* TYA */entry static Op98Transfer( rY, rA )EndOpcode( 2 )//case 0xA8: Y=A;M_FL(Y);break;       /* TAY */entry static OpA8Transfer( rA, rY )EndOpcode( 2 )//case 0xC8: Y++;M_FL(Y);break;          /* INY */entry static OpC8Increment( rY, rY )EndOpcode( 2 )//case 0x88: Y--;M_FL(Y);break;          /* DEY */entry static Op88Decrement( rY, rY )EndOpcode( 2 )//case 0x8A: A=X;M_FL(A);break;       /* TXA */entry static Op8ATransfer( rX, rA )EndOpcode( 2 )//case 0xAA: X=A;M_FL(X);break;       /* TAX */entry static OpAATransfer( rA, rX )EndOpcode( 2 )//case 0xE8: X++;M_FL(X);break;          /* INX */entry static OpE8Increment( rX, rX )EndOpcode( 2 )//case 0xCA: X--;M_FL(X);break;          /* DEX */entry static OpCADecrement( rX, rX )EndOpcode( 2 )//case 0xEA: break;                            /* NOP */entry static OpEAEndOpcode( 2 )//case 0x9A: S=X;break;                  /* TXS */entry static Op9ATransferWithoutFlag( rX, rS )EndOpcode( 2 )//case 0xBA: X=S;break;                  /* TSX */entry static OpBATransferWithoutFlag( rS, rX )EndOpcode( 2 )//case 0x05: MR_Zp(I);M_ORA(I);break;       /* ORA $ss ZP */entry static Op05ZeroPageReadOr( r3 )EndOpcode( 3 )//case 0x06: MM_Zp(M_ASL);break;            /* ASL $ss ZP */entry static Op06ZeroPageModifyStartArithmeticShiftLeft( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0x25: MR_Zp(I);M_AND(I);break;       /* AND $ss ZP */entry static Op25ZeroPageReadAnd( r3 )EndOpcode( 3 )//case 0x26: MM_Zp(M_ROL);break;            /* ROL $ss ZP */entry static Op26ZeroPageModifyStartRotateLeft( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0x45: MR_Zp(I);M_EOR(I);break;       /* EOR $ss ZP */entry static Op45ZeroPageReadXor( r3 )EndOpcode( 3 )//case 0x46: MM_Zp(M_LSR);break;            /* LSR $ss ZP */entry static Op46ZeroPageModifyStartLogicalShiftRight( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0x65: MR_Zp(I);M_ADC(I);break;       /* ADC $ss ZP */entry static Op65ZeroPageReadAddWithCarry( r3, Op65 )EndOpcode( 3 )//case 0x66: MM_Zp(M_ROR);break;            /* ROR $ss ZP */entry static Op66ZeroPageModifyStartRotateRight( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0x84: MW_Zp(Y);break;             /* STY $ss ZP */entry static Op84ZeroPageWrite( rY )EndOpcode( 3 )//case 0x85: MW_Zp(A);break;             /* STA $ss ZP */entry static Op85ZeroPageWrite( rA )EndOpcode( 3 )//case 0x86: MW_Zp(X);break;             /* STX $ss ZP */entry static Op86ZeroPageWrite( rX )EndOpcode( 3 )//case 0xA4: MR_Zp(Y);M_FL(Y);break;  /* LDY $ss ZP */entry static OpA4ZeroPageReadTransfer( r3, rY )EndOpcode( 3 )//case 0xA5: MR_Zp(A);M_FL(A);break;  /* LDA $ss ZP */entry static OpA5ZeroPageReadTransfer( r3, rA )EndOpcode( 3 )//case 0xA6: MR_Zp(X);M_FL(X);break;  /* LDX $ss ZP */entry static OpA6ZeroPageReadTransfer( r3, rX )EndOpcode( 3 )//case 0xC4: MR_Zp(I);M_CMP(Y,I);break;  /* CPY $ss ZP */entry static OpC4ZeroPageReadCompare( rY, r3 )EndOpcode( 3 )//case 0xC5: MR_Zp(I);M_CMP(A,I);break;  /* CMP $ss ZP */entry static OpC5ZeroPageReadCompare( rA, r3 )EndOpcode( 3 )//case 0xC6: MM_Zp(M_DEC);break;            /* DEC $ss ZP */entry static OpC6ZeroPageModifyStartDecrement( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0xE4: MR_Zp(I);M_CMP(X,I);break;  /* CPX $ss ZP */entry static OpE4ZeroPageReadCompare( rX, r3 )EndOpcode( 3 )//case 0xE5: MR_Zp(I);M_SBC(I);break;       /* SBC $ss ZP */entry static OpE5ZeroPageReadSubtractWithCarry( r3, OpE5 )EndOpcode( 3 )//case 0xE6: MM_Zp(M_INC);break;            /* INC $ss ZP */entry static OpE6ZeroPageModifyStartIncrement( r3, r4 )ZeroPageModifyEndEndOpcode( 5 )//case 0x24: MR_Zp(I);M_BIT(I);break;       /* BIT $ss ZP */entry static Op24ZeroPageReadBitwiseCompare( r3 )EndOpcode( 3 )//case 0x2C: MR_Ab(I);M_BIT(I);break;       /* BIT $ssss ABS */entry static Op2CAbsoluteRead( Op2C )BitwiseCompare( r3 )EndOpcode( 4 )//case 0x0D: MR_Ab(I);M_ORA(I);break;       /* ORA $ssss ABS */entry static Op0DAbsoluteRead( Op0D )Or( r3 )EndOpcode( 4 )//case 0x0E: MM_Ab(M_ASL);break;            /* ASL $ssss ABS */entry static Op0EAbsoluteModifyStart( Op0E )ArithmeticShiftLeft( r3, r4 )AbsoluteModifyEnd( Op0E )EndOpcode( 6 )//case 0x2D: MR_Ab(I);M_AND(I);break;       /* AND $ssss ABS */entry static Op2DAbsoluteRead( Op2D )And( r3 )EndOpcode( 4 )//case 0x2E: MM_Ab(M_ROL);break;            /* ROL $ssss ABS */entry static Op2EAbsoluteModifyStart( Op2E )RotateLeft( r3, r4 )AbsoluteModifyEnd( Op2E )EndOpcode( 6 )//case 0x4D: MR_Ab(I);M_EOR(I);break;       /* EOR $ssss ABS */entry static Op4DAbsoluteRead( Op4D )Xor( r3 )EndOpcode( 4 )//case 0x4E: MM_Ab(M_LSR);break;            /* LSR $ssss ABS */entry static Op4EAbsoluteModifyStart( Op4E )LogicalShiftRight( r3, r4 )AbsoluteModifyEnd( Op4E )EndOpcode( 6 )//case 0x6D: MR_Ab(I);M_ADC(I);break;       /* ADC $ssss ABS */entry static Op6DAbsoluteRead( Op6D )AddWithCarry( r3, Op6D )EndOpcode( 4 )//case 0x6E: MM_Ab(M_ROR);break;            /* ROR $ssss ABS */entry static Op6EAbsoluteModifyStart( Op6E )RotateRight( r3, r4 )AbsoluteModifyEnd( Op6E )EndOpcode( 6 )//case 0x8C: MW_Ab(Y);break;             /* STY $ssss ABS */entry static Op8CAbsoluteWrite( rY, Op8C )EndOpcode( 4 )//case 0x8D: MW_Ab(A);break;             /* STA $ssss ABS */entry static Op8DAbsoluteWrite( rA, Op8D )EndOpcode( 4 )//case 0x8E: MW_Ab(X);break;             /* STX $ssss ABS */entry static Op8EAbsoluteWrite( rX, Op8E )EndOpcode( 4 )//case 0xAC: MR_Ab(Y);M_FL(Y);break;  /* LDY $ssss ABS */entry static OpACAbsoluteRead( OpAC )Transfer( r3, rY )EndOpcode( 4 )//case 0xAD: MR_Ab(A);M_FL(A);break;  /* LDA $ssss ABS */entry static OpADAbsoluteRead( OpAD )Transfer( r3, rA )EndOpcode( 4 )//case 0xAE: MR_Ab(X);M_FL(X);break;  /* LDX $ssss ABS */entry static OpAEAbsoluteRead( OpAE )Transfer( r3, rX )EndOpcode( 4 )//case 0xCC: MR_Ab(I);M_CMP(Y,I);break;  /* CPY $ssss ABS */entry static OpCCAbsoluteRead( OpCC )Compare( rY, r3 )EndOpcode( 4 )//case 0xCD: MR_Ab(I);M_CMP(A,I);break;  /* CMP $ssss ABS */entry static OpCDAbsoluteRead( OpCD )Compare( rA, r3 )EndOpcode( 4 )//case 0xCE: MM_Ab(M_DEC);break;            /* DEC $ssss ABS */entry static OpCEAbsoluteModifyStart( OpCE )Decrement( r3, r4 )AbsoluteModifyEnd( OpCE )EndOpcode( 6 )//case 0xEC: MR_Ab(I);M_CMP(X,I);break;  /* CPX $ssss ABS */entry static OpECAbsoluteRead( OpEC )Compare( rX, r3 )EndOpcode( 4 )//case 0xED: MR_Ab(I);M_SBC(I);break;       /* SBC $ssss ABS */entry static OpEDAbsoluteRead( OpED )SubtractWithCarry( r3, OpED )EndOpcode( 4 )//case 0xEE: MM_Ab(M_INC);break;            /* INC $ssss ABS */entry static OpEEAbsoluteModifyStart( OpEE )Increment( r3, r4 )AbsoluteModifyEnd( OpEE )EndOpcode( 6 )//case 0x09: MR_Im(I);M_ORA(I);break;       /* ORA #$ss IMM */entry static Op09ImmediateRead( r3 )Or( r3 )EndOpcode( 2 )//case 0x29: MR_Im(I);M_AND(I);break;       /* AND #$ss IMM */entry static Op29ImmediateRead( r3 )And( r3 )EndOpcode( 2 )//case 0x49: MR_Im(I);M_EOR(I);break;       /* EOR #$ss IMM */entry static Op49ImmediateRead( r3 )Xor( r3 )EndOpcode( 2 )//case 0x69: MR_Im(I);M_ADC(I);break;       /* ADC #$ss IMM */entry static Op69ImmediateRead( r3 )AddWithCarry( r3, Op69 )EndOpcode( 2 )//case 0xA0: MR_Im(Y);M_FL(Y);break;  /* LDY #$ss IMM */entry static OpA0ImmediateRead( rY )SetZN( rY )EndOpcode( 2 )//case 0xA2: MR_Im(X);M_FL(X);break;  /* LDX #$ss IMM */entry static OpA2ImmediateRead( rX )SetZN( rX )EndOpcode( 2 )//case 0xA9: MR_Im(A);M_FL(A);break;  /* LDA #$ss IMM */entry static OpA9ImmediateRead( rA )SetZN( rA )EndOpcode( 2 )//case 0xC0: MR_Im(I);M_CMP(Y,I);break;  /* CPY #$ss IMM */entry static OpC0ImmediateRead( r3 )Compare( rY, r3 )EndOpcode( 2 )//case 0xC9: MR_Im(I);M_CMP(A,I);break;  /* CMP #$ss IMM */entry static OpC9ImmediateRead( r3 )Compare( rA, r3 )EndOpcode( 2 )//case 0xE0: MR_Im(I);M_CMP(X,I);break;  /* CPX #$ss IMM */entry static OpE0ImmediateRead( r3 )Compare( rX, r3 )EndOpcode( 2 )//case 0xE9: MR_Im(I);M_SBC(I);break;       /* SBC #$ss IMM */entry static OpE9ImmediateRead( r3 )SubtractWithCarry( r3, OpE9 )EndOpcode( 2 )//case 0x15: MR_Zx(I);M_ORA(I);break;       /* ORA $ss,x ZP,x */entry static Op15ZeroPageIndexRead( rX )Or( r3 )EndOpcode( 4 )//case 0x16: MM_Zx(M_ASL);break;            /* ASL $ss,x ZP,x */entry static Op16ZeroPageIndexModifyStart( rX )ArithmeticShiftLeft( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0x35: MR_Zx(I);M_AND(I);break;       /* AND $ss,x ZP,x */entry static Op35ZeroPageIndexRead( rX )And( r3 )EndOpcode( 4 )//case 0x36: MM_Zx(M_ROL);break;            /* ROL $ss,x ZP,x */entry static Op36ZeroPageIndexModifyStart( rX )RotateLeft( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0x55: MR_Zx(I);M_EOR(I);break;       /* EOR $ss,x ZP,x */entry static Op55ZeroPageIndexRead( rX )Xor( r3 )EndOpcode( 4 )//case 0x56: MM_Zx(M_LSR);break;            /* LSR $ss,x ZP,x */entry static Op56ZeroPageIndexModifyStart( rX )LogicalShiftRight( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0x75: MR_Zx(I);M_ADC(I);break;       /* ADC $ss,x ZP,x */entry static Op75ZeroPageIndexRead( rX )AddWithCarry( r3, Op75 )EndOpcode( 4 )//case 0x76: MM_Zx(M_ROR);break;            /* ROR $ss,x ZP,x */entry static Op76ZeroPageIndexModifyStart( rX )RotateRight( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0x94: MW_Zx(Y);break;             /* STY $ss,x ZP,x */entry static Op94ZeroPageIndexWrite( rX, rY )EndOpcode( 4 )//case 0x95: MW_Zx(A);break;             /* STA $ss,x ZP,x */entry static Op95ZeroPageIndexWrite( rX, rA )EndOpcode( 4 )//case 0x96: MW_Zy(X);break;             /* STX $ss,y ZP,y */entry static Op96ZeroPageIndexWrite( rY, rX )EndOpcode( 4 )//case 0xB4: MR_Zx(Y);M_FL(Y);break;  /* LDY $ss,x ZP,x */entry static OpB4ZeroPageIndexRead( rX )Transfer( r3, rY )EndOpcode( 4 )//case 0xB5: MR_Zx(A);M_FL(A);break;  /* LDA $ss,x ZP,x */entry static OpB5ZeroPageIndexRead( rX )Transfer( r3, rA )EndOpcode( 4 )//case 0xB6: MR_Zy(X);M_FL(X);break;  /* LDX $ss,y ZP,y */entry static OpB6ZeroPageIndexRead( rY )Transfer( r3, rX )EndOpcode( 4 )//case 0xD5: MR_Zx(I);M_CMP(A,I);break;  /* CMP $ss,x ZP,x */entry static OpD5ZeroPageIndexRead( rX )Compare( rA, r3 )EndOpcode( 4 )//case 0xD6: MM_Zx(M_DEC);break;            /* DEC $ss,x ZP,x */entry static OpD6ZeroPageIndexModifyStart( rX )Decrement( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0xF5: MR_Zx(I);M_SBC(I);break;       /* SBC $ss,x ZP,x */entry static OpF5ZeroPageIndexRead( rX )SubtractWithCarry( r3, OpF5 )EndOpcode( 4 )//case 0xF6: MM_Zx(M_INC);break;            /* INC $ss,x ZP,x */entry static OpF6ZeroPageIndexModifyStart( rX )Increment( r3, r4 )ZeroPageIndexModifyEnd( rX )EndOpcode( 6 )//case 0x19: MR_Ay(I);M_ORA(I);break;       /* ORA $ssss,y ABS,y */entry static Op19AbsoluteIndexRead( rY, Op19 )Or( r3 )EndOpcode( 4 )//case 0x1D: MR_Ax(I);M_ORA(I);break;       /* ORA $ssss,x ABS,x */entry static Op1DAbsoluteIndexRead( rX, Op1D )Or( r3 )EndOpcode( 5 )//case 0x1E: MM_Ax(M_ASL);break;            /* ASL $ssss,x ABS,x */entry static Op1EAbsoluteIndexModifyStart( rX, Op1E )ArithmeticShiftLeft( r3, r4 )AbsoluteIndexModifyEnd( rX, Op1E )EndOpcode( 7 )//case 0x39: MR_Ay(I);M_AND(I);break;       /* AND $ssss,y ABS,y */entry static Op39AbsoluteIndexRead( rY, Op39 )And( r3 )EndOpcode( 4 )//case 0x3D: MR_Ax(I);M_AND(I);break;       /* AND $ssss,x ABS,x */entry static Op3DAbsoluteIndexRead( rX, Op3D )And( r3 )EndOpcode( 5 )//case 0x3E: MM_Ax(M_ROL);break;            /* ROL $ssss,x ABS,x */entry static Op3EAbsoluteIndexModifyStart( rX, Op3E )RotateLeft( r3, r4 )AbsoluteIndexModifyEnd( rX, Op3E )EndOpcode( 7 )//case 0x59: MR_Ay(I);M_EOR(I);break;       /* EOR $ssss,y ABS,y */entry static Op59AbsoluteIndexRead( rY, Op59 )Xor( r3 )EndOpcode( 4 )//case 0x5D: MR_Ax(I);M_EOR(I);break;       /* EOR $ssss,x ABS,x */entry static Op5DAbsoluteIndexRead( rX, Op5D )Xor( r3 )EndOpcode( 5 )//case 0x5E: MM_Ax(M_LSR);break;            /* LSR $ssss,x ABS,x */entry static Op5EAbsoluteIndexModifyStart( rX, Op5E )LogicalShiftRight( r3, r4 )AbsoluteIndexModifyEnd( rX, Op5E )EndOpcode( 7 )//case 0x79: MR_Ay(I);M_ADC(I);break;       /* ADC $ssss,y ABS,y */entry static Op79AbsoluteIndexRead( rY, Op79 )AddWithCarry( r3, Op79 )EndOpcode( 4 )//case 0x7D: MR_Ax(I);M_ADC(I);break;       /* ADC $ssss,x ABS,x */entry static Op7DAbsoluteIndexRead( rX, Op7D )AddWithCarry( r3, Op7D )EndOpcode( 5 )//case 0x7E: MM_Ax(M_ROR);break;            /* ROR $ssss,x ABS,x */entry static Op7EAbsoluteIndexModifyStart( rX, Op7E )RotateRight( r3, r4 )AbsoluteIndexModifyEnd( rX, Op7E )EndOpcode( 7 )//case 0x99: MW_Ay(A);break;             /* STA $ssss,y ABS,y */entry static Op99AbsoluteIndexWrite( rY, rA, Op99 )EndOpcode( 5 )//case 0x9D: MW_Ax(A);break;             /* STA $ssss,x ABS,x */entry static Op9DAbsoluteIndexWrite( rX, rA, Op9D )EndOpcode( 5 )//case 0xB9: MR_Ay(A);M_FL(A);break;  /* LDA $ssss,y ABS,y */entry static OpB9AbsoluteIndexRead( rY, OpB9 )Transfer( r3, rA )EndOpcode( 4 )//case 0xBC: MR_Ax(Y);M_FL(Y);break;  /* LDY $ssss,x ABS,x */entry static OpBCAbsoluteIndexRead( rX, OpBC )Transfer( r3, rY )EndOpcode( 4 )//case 0xBD: MR_Ax(A);M_FL(A);break;  /* LDA $ssss,x ABS,x */entry static OpBDAbsoluteIndexRead( rX, OpBD )Transfer( r3, rA )EndOpcode( 4 )//case 0xBE: MR_Ay(X);M_FL(X);break;  /* LDX $ssss,y ABS,y */entry static OpBEAbsoluteIndexRead( rY, OpBE )Transfer( r3, rX )EndOpcode( 4 )//case 0xD9: MR_Ay(I);M_CMP(A,I);break;  /* CMP $ssss,y ABS,y */entry static OpD9AbsoluteIndexRead( rY, OpD9 )Compare( rA, r3 )EndOpcode( 4 )//case 0xDD: MR_Ax(I);M_CMP(A,I);break;  /* CMP $ssss,x ABS,x */entry static OpDDAbsoluteIndexRead( rX, OpDD )Compare( rA, r3 )EndOpcode( 5 )//case 0xDE: MM_Ax(M_DEC);break;            /* DEC $ssss,x ABS,x */entry static OpDEAbsoluteIndexModifyStart( rX, OpDE )Decrement( r3, r4 )AbsoluteIndexModifyEnd( rX, OpDE )EndOpcode( 7 )//case 0xF9: MR_Ay(I);M_SBC(I);break;       /* SBC $ssss,y ABS,y */entry static OpF9AbsoluteIndexRead( rY, OpF9 )SubtractWithCarry( r3, OpF9 )EndOpcode( 4 )//case 0xFD: MR_Ax(I);M_SBC(I);break;       /* SBC $ssss,x ABS,x */entry static OpFDAbsoluteIndexRead( rX, OpFD )SubtractWithCarry( r3, OpFD )EndOpcode( 5 )//case 0xFE: MM_Ax(M_INC);break;            /* INC $ssss,x ABS,x */entry static OpFEAbsoluteIndexModifyStart( rX, OpFE )Increment( r3, r4 )AbsoluteIndexModifyEnd( rX, OpFE )EndOpcode( 7 )//case 0x01: MR_Ix(I);M_ORA(I);break;       /* ORA ($ss,x) INDEXINDIR */entry static Op01IndexIndirReadOr( r3 )EndOpcode( 6 )//case 0x11: MR_Iy(I);M_ORA(I);break;       /* ORA ($ss),y INDIRINDEX */entry static Op11IndirIndexReadOr( r3 )EndOpcode( 5 )//case 0x21: MR_Ix(I);M_AND(I);break;       /* AND ($ss,x) INDEXINDIR */entry static Op21IndexIndirReadAnd( r3 )EndOpcode( 6 )//case 0x31: MR_Iy(I);M_AND(I);break;       /* AND ($ss),y INDIRINDEX */entry static Op31IndirIndexReadAnd( r3 )EndOpcode( 5 )//case 0x41: MR_Ix(I);M_EOR(I);break;       /* EOR ($ss,x) INDEXINDIR */entry static Op41IndexIndirReadXor( r3 )EndOpcode( 6 )//case 0x51: MR_Iy(I);M_EOR(I);break;       /* EOR ($ss),y INDIRINDEX */entry static Op51IndirIndexReadXor( r3 )EndOpcode( 5 )//case 0x61: MR_Ix(I);M_ADC(I);break;       /* ADC ($ss,x) INDEXINDIR */entry static Op61IndexIndirReadAddWithCarry( r3, Op61 )EndOpcode( 6 )//case 0x71: MR_Iy(I);M_ADC(I);break;       /* ADC ($ss),y INDIRINDEX */entry static Op71IndirIndexReadAddWithCarry( r3, Op71 )EndOpcode( 5 )//case 0x81: MW_Ix(A);break;             /* STA ($ss,x) INDEXINDIR */entry static Op81IndexIndirWrite( rA )EndOpcode( 6 )//case 0x91: MW_Iy(A);break;             /* STA ($ss),y INDIRINDEX */entry static Op91IndirIndexWrite( rA )EndOpcode( 6 )//case 0xA1: MR_Ix(A);M_FL(A);break;  /* LDA ($ss,x) INDEXINDIR */entry static OpA1IndexIndirReadTransfer( r3, rA )EndOpcode( 6 )//case 0xB1: MR_Iy(A);M_FL(A);break;  /* LDA ($ss),y INDIRINDEX */entry static OpB1IndirIndexReadTransfer( r3, rA )EndOpcode( 5 )//case 0xC1: MR_Ix(I);M_CMP(A,I);break;  /* CMP ($ss,x) INDEXINDIR */entry static OpC1IndexIndirReadCompare( rA, r3 )EndOpcode( 6 )//case 0xD1: MR_Iy(I);M_CMP(A,I);break;  /* CMP ($ss),y INDIRINDEX */entry static OpD1IndirIndexReadCompare( rA, r3 )EndOpcode( 5 )//case 0xE1: MR_Ix(I);M_SBC(I);break;       /* SBC ($ss,x) INDEXINDIR */entry static OpE1IndexIndirReadSubtractWithCarry( r3, OpE1 )EndOpcode( 6 )//case 0xF1: MR_Iy(I);M_SBC(I);break;       /* SBC ($ss),y INDIRINDEX */entry static OpF1IndirIndexReadSubtractWithCarry( r3, OpF1 )EndOpcode( 5 )//case 0x0A: M_ASL(A);break;             /* ASL a ACC */entry static Op0AArithmeticShiftLeft( rA, rA )EndOpcode( 2 )//case 0x2A: M_ROL(A);break;             /* ROL a ACC */entry static Op2ARotateLeft( rA, rA )EndOpcode( 2 )//case 0x4A: M_LSR(A);break;             /* LSR a ACC */entry static Op4ALogicalShiftRight( rA, rA )EndOpcode( 2 )//case 0x6A: M_ROR(A);break;             /* ROR a ACC */entry static Op6ARotateRight( rA, rA )EndOpcode( 2 )// unused opcodes (warning might be good?)entry static OpXXb      parseOpcodefinished:mr     r3, rPClwz		r0,136(sp)addi	sp,sp,128mtlr	r0lmw		r13,-76(sp)blr}#endif